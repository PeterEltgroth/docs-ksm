---
title: Release Notes
owner: Platform Engineering (KSM Team)
---

<strong><%= modified_date %></strong>

<%# The below partial is in https://github.com/pivotal-cf/docs-partials %>

<%= partial "../../ksm/partials/services/beta-notice" %>

These are release notes for <%= vars.product_full %>.

##<a id="v0.X.XX"></a> v0.X.XX

**Release Date:** XXXX XX, 2019

<p class="note"><strong>Note:</strong> This release is incompatible with previous
  releases of <%= vars.product_short %>. This is because <%= vars.product_short %> v0.X.XX xxxxxxxxxxxxxxxx.
  It is recommended to delete the service instances and the Tile from previous releases of <%= vars.product_short %>
  before installing <%= vars.product_short %> v0.X.XX. You must add your offerings again.
  To do this, do the procedures in
  <a href="./using.html#add">Add a Service Offering to <%= vars.product_short %> </a>
   and <a href="./using.html#enable">Enable Service Offering Access</a>.
  </p>

### Features

New features and changes in this release:

* Platform operators can offer services that have multiple Helm charts.
For more information, see [(Optional) Offer Multiple Charts in a Single Offering](#multiple-charts).
* The KSM CLI replaces the Bazaar CLI.
* Binding credentials are automatically stored in runtime CredHub.
This requires <%= vars.product_short %> to be installed on a <%= vars.pas_short %> deployment
with CredHub enabled. For instructions about enabling CredHub,
see [Securing Services Instance Credentials with Runtime CredHub](https://docs.pivotal.io/pivotalcf/2-6/opsguide/secure-si-creds.html).

### Known Issues

Upgrading from previous versions of KSM Tile will leave orphaned service instances and service broker.
It is recommended to delete the service instances and the Tile from previous releases of <%= vars.product_short %>
before installing <%= vars.product_short %> v0.X.XX, instead of upgrading the Tile.

If your chart uses a custom resource, there is a small window of time in which the broker will report service was
provisioned successfully. However, the custom objects have not yet been created. This is due to Kubernetes not having a
generic way to detect resource readiness. Kubernetes primitives have known patterns for detecting readiness, while
readiness for a custom resource is defined by its author.