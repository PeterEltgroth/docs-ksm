---
title: Architecture
owner: Platform Engineering (KSM Team)
---
<strong><%= modified_date %></strong>

<%= partial ("beta-notice") %>

This topic describes <%= vars.product_full %> components, architecture, and technical detail.

##<a id='overview'></a> Overview

<%= vars.product_short %> is a collection of components running on a BOSH deployed
VM that communicates with both Kubernetes clusters and PCF.

The following diagram describes how <%= vars.product_short %> communicates with
PCF and a Kubernetes cluster:

<a href="images/reference_architecture.jpg" target="_blank">
    <img src="images/reference_architecture.jpg" alt="<%= vars.product_short %> reference architecture">
</a>

<%# The above diagram should probably be simplified or split up. It is hard to follow and read since the text is small. We also should write more text below that explains or describes the diagram in more detail for clarity/accessibility reasons. %>

<%= vars.product_short %> consists of the following components:

* [KSM Daemon](#ksm-d)
* [KSM Broker](#ksm-broker)

And uses external resources:

* [S3 Compatible Storage](#state)
* [Kubernetes Clusters](#clusters)

##<a id='ksm-d'></a> KSM Daemon

The <% vars.pas_short %> daemon (ksm-d) provides the API that the KSM CLI communicates with.
When an operator saves a Helm chart,
the ksm-d component validates the chart and stores it in
[ChartMuseum](https://github.com/helm/chartmuseum).
If you provide a descriptor in your `ksm.yaml` file, this component stores
that yaml file as well.

For more information about Helm charts and the `ksm.yaml` file,
see [Preparing an Offer](./prepare-offer.html).

##<a id='ksm-broker'></a> KSM Broker

The KSM broker is an Open Service Broker.
When a <%= vars.platform %> developer runs `cf create-service`,
the Cloud Controller sends that request to the broker. The broker then deploys
the Helm chart needed for the service.

For more information about Open Service Brokers,
see [Open Service Broker](https://www.openservicebrokerapi.org/).

Dedicated instances are provided through a service broker installed by the <%= vars.product_short %> tile.
When a <% vars.pas_short %> developer runs `cf create-service`
the broker creates a dedicated service instance of the service in the backing cluster.

For more
information about the `cf create-service` command,
see [Creating Service Instances](https://docs.cloudfoundry.org/devguide/services/managing-services.html#create)
in the Cloud Foundry documentation.


## <a id='state'></a> S3 State

Both ChartMuseum and the <% vars.pas_short %> daemon store state in
the configured S3 bucket. 
For information about configuring an S3 bucket, see [Prerequisites](./installing.html#storage-preq).

The daemon also uses this bucket to persist its cache.

## <a id='clusters'></a> Kubernetes Clusters

<%= vars.product_short %> is backed by at least one
[default cluster](./installing.html#kubeconfig).
Individual offering plans can override this cluster as well.
<%# todo: link to configuring plan specific credentials %>
This configuration scheme allows a large, default cluster to be used for more ephemeral
service instances, like those used in dev, and clusters with more workload specialized configurations to be
dedicated to specific service plans.

<%= vars.product_short %> creates multiple namespaces.

* On installation, <%= vars.product_short %> creates a `kibosh` into which it installs Helm's
[Tiller](https://helm.sh/docs/install/), secured via mTLS where
the CA certificate is the
[Ops Manager Root CA](https://docs.pivotal.io/pivotalcf/security/pcf-infrastructure/managing-certificates.html).
* Each instance is deployed into its own namespace, named `kibosh-xxxx`,
where `xxxx` is the `instance_id` generated by <%= vars.pas_short %>.
* Each chart having scope `cluster` is provisioned once per cluster in a namespace named `ksm-<chart-name>`.

<%= vars.product_short %> does not internally track these identifiers and uses
the predictable namespace names to reach resources in backing clusters.

##<a id='osbapi'></a> Detailed Life Cycle

This section outlines what happens at each phase of the life cycle: bind, update, unbind, and deprovision.

###<a id='provision'></a> Provision
When a service instance is provisioned, <%= vars.product_short %> checks the scope and then
loops through the list of charts.
For more information, see [Preparing an Offer](./prepare-offer.html).

Each chart is then serially deployed into the backing Kubernetes cluster,
and subsequent charts wait for the previous chart to be fully installed.

####<a id='provision_cluster_scope'></a> Cluster Scope

When the chart's scope is `cluster`, <%= vars.product_short %> checks for a namespace
named `ksm-<chart-name>`. If the namespace is present, the `cluster` scoped chart is not added.

When the namespace is not present, <%= vars.product_short %> does the following:

* Creates the namespace named `ksm-<chart-name>` for the cluster scoped chart
* Deploys the chart into the namespace
* Waits for the deployment to succeed

If <%= vars.product_short %> is configured with a private registry, it does the following:

* Transforms the chart's image reference  to pull to from that registry (assuming the image/registry key names used match expectations)
* Adds a secret containing the registry credentials to the namespace, so the image can be pulled

####<a id='provision_namespace_scope'></a> Namespace Scope

When the chart's scope is `namespace`, the broker does the following:

* Creates a new namespace in the cluster. This namespace is named `kibosh-xxxx`, where `xxxx` is the
`instance_id` generated by <%= vars.pas_short %>
* Deploys the chart into the namespace
* Waits for the deployment to succeed

If <%= vars.product_short %> is configured with a private registry, it does the following:

* Transforms the chart's image reference  to pull to from that registry (assuming the image/registry key names used match expectations)
* Adds a secret containing the registry credentials to the namespace, so the image can be pulled

###<a id='bind'></a> Bind

On bind, <%= vars.product_short %> looks at the `services` and `secrets` created
in the  namespace created on provision.

If the chart includes a [bind template](./prepare-offer.html#env), these
`services` and `secrets` are fed into that template, processed, and the template
results are used as the credentials.

If the chart does not include a bind template, the `services` and `secrets` are
used directly as credentials (serialized as JSON).

<%= vars.product_short %> takes the credentials and then stores them
in the Pivotal Application Service CredHub.
<%# Not to docs folks: to be technically accurate, this needs to be PAS credhub - can't be platform or something generic %>
The bound application is given permission to read the newly created CredHub variable.

###<a id='update'></a> Update

When a developer invokes update via <%= vars.pas_short %>, Helm's
[upgrade lifecycle](https://github.com/helm/helm/blob/master/docs/helm/helm_upgrade.md)
is triggered for the chart.

* The update does **not** consume a newer version of the chart if one has been offered
* Existing values are used, so the developer does not need to resend all the configuration parameters

The use case for update is to add or modify configuration parameters sent via the `-c`
flag on service provision or update.

###<a id='provision'></a> Unbind

On unbind, <%= vars.product_short %> deletes the CredHub variables
[created during bind](#bind).

###<a id='provision'></a> Deprovision

On deprovision, <%= vars.product_short %> does the following:

* Deletes each chart of scope `namespace` created during provision
* Takes no action on charts of scope `cluster`
* Deletes the namespace in the backing cluster generated during provision
