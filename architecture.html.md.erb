---
title: Architecture
owner: Platform Engineering (KSM Team)
---
<strong><%= modified_date %></strong>

<%= partial ("beta-notice") %>

This topic describes <%= vars.product_full %> components, architecture, and technical detail.

##<a id='overview'></a> Overview

<%= vars.product_short %> is a collection of components running on a BOSH deployed
VM that communicates with both Kubernetes clusters and <%= vars.platform %>.

The following diagram describes how <%= vars.product_short %> communicates with
<%= vars.platform %> and a Kubernetes cluster:

<a href="images/reference_architecture.jpg" target="_blank">
    <img src="images/reference_architecture.jpg" alt="<%= vars.product_short %> reference architecture">
</a>

<a href="images/reference_architecture.jpg" target="_blank"> View a larger version of this diagram.</a>

<%# The above diagram should probably be simplified or split up. It is hard to follow and read since the text is small. We also should write more text below that explains or describes the diagram in more detail for clarity/accessibility reasons. %>

##<a id='components'></a> <%= vars.product_short %> Components

<%= vars.product_short %> contains the following components:

* [KSM Daemon](#ksm-d)
* [KSM Broker](#ksm-broker)

###<a id='ksm-d'></a> KSM Daemon

The <%= vars.product_short %> daemon (ksm-d) provides the API that the KSM CLI communicates with.
When a platform operator saves a Helm chart,
ksm-d validates the chart and stores it in ChartMuseum. For information about ChartMuseum,
see the [chartmuseum](https://github.com/helm/chartmuseum) repository on GitHub

If you provide a `ksm.yaml` file, ksm-d stores
the yaml file. For more information about the `ksm.yaml` file,
see [(Optional) Offer Multiple Charts in a Single Offering](./prepare-offer.html#multiple-charts).

###<a id='ksm-broker'></a> KSM Broker

The KSM broker is an Open Service Broker that creates
dedicated service instances in the backing cluster.
When a <% vars.pas_short %> developer runs `cf create-service`
Cloud Controller sends that request to the broker. The broker then deploys
the Helm chart needed for the service.

For more information about Open Service Brokers,
see [Open Service Broker](https://www.openservicebrokerapi.org/).

For more
information about the `cf create-service` command,
see [Creating Service Instances](https://docs.cloudfoundry.org/devguide/services/managing-services.html#create)
in the Cloud Foundry documentation.

##<a id='resources'></a> <%= vars.product_short %> Resources

<%= vars.product_short %> uses the following external resources:

* [S3 Compatible Bucket](#state)
* [Kubernetes Clusters](#clusters)


### <a id='state'></a> S3 Compatible Bucket
<%= vars.product_short %> uses an external S3 compatible bucket to store the state of
ChartMuseum and the <%= vars.product_short %> daemon.
The <%= vars.product_short %> daemon uses this bucket to persist its cache.

For instructions for configuring an external S3 compatible bucket
for <%= vars.product_short %>, see [Configure Storage](./installing.html#storage).



### <a id='clusters'></a> Kubernetes Clusters

<%= vars.product_short %> is backed by at least one default cluster.
You can override this default cluster with service offering plans.
<%# todo: link to configuring plan specific credentials %>

You can use different service offering plans to configure different types of clusters.
For example, you could configure a large default cluster for more ephemeral
service instances used in development.
You could also configure a cluster with more workload specialization for specific service plans.

For instructions about configuring a default Kubernetes cluster,
see [Configure Cluster Credentials](./installing.html#kubeconfig)

<%= vars.product_short %> creates the following namespaces in the cluster:

* **`kibosh`:** During installation, <%= vars.product_short %> creates a `kibosh` namespace
and installs Tiller with mTLS into the namespace.
For information about Tiller, see [Tiller](https://helm.sh/docs/glossary/#tiller)
in the Helm documentation.

* **Service instance namespaces:** When a service instance is created,
<%= vars.product_short %> deploys the instance into a unique namespace.
This name for the namespace is formatted as `kibosh-ID`, where `ID`
is the `instance_id` for the service instance.
* **Chart namespaces:** Charts with the `cluster` scope are provisioned once per
cluster in a namespace named `ksm-CHART`, where `CHART` is the name of the chart.

<%= vars.product_short %> does not internally track these identifiers and uses
the predictable namespace names to reach resources in backing clusters.

## <a id='life-cycle'></a> <%= vars.product_short %> Life Cycle

This section outlines what happens when you use the
Cloud Foundry Command Line Interface (cf CLI) to create, bind,
update, unbind, and delete service instances.

For information about the cf CLI,
see [Managing Service Instances with the cf CLI](https://docs.cloudfoundry.org/devguide/services/managing-services.html)
in the Cloud Foundry documentation.

###<a id='provision'></a> Create
When a <%= vars.pas_short %>  developer runs `cf create-service`,
<%= vars.product_short %> loops through the list of charts that the platform operator provided in
Preparing an Offer](./prepare-offer.html).
For each chart, <%= vars.product_short %> checks the scope for the chart and deploys the chart in
the correct namespace. <%= vars.product_short %> serially deploys the charts
into the backing Kubernetes cluster and does not deploy
subsequent charts until the previous chart is fully installed.

####<a id='cluster-scope'></a> Cluster Scope

When the chart's scope is `cluster`, <%= vars.product_short %> will check for a namespace
named `ksm-<chart-name>`. If the namespace is present, the `cluster` scoped chart won't be added.

When the namespace isn't present, <%= vars.product_short %> will

* Create the namespace named `ksm-<chart-name>` for the cluster scoped chart
* Deploy the chart into the namespace
* Wait for the deployment to succeed

If <%= vars.product_short %> is configured with a private registry, it will

* Transform the chart's image reference  to pull to from that registry (assuming the image/registry key names used match expectations)
* Add a secret containing the registry credentials to the namespace, so the image can be pulled

####<a id='namespace-scope'></a> Namespace Scope

When the chart's scope is `namespace`, the broker will

* Creates a new namespace in the cluster. This namespace is named `kibosh-xxxx`, where `xxxx` is the
`instance_id` generated by <%= vars.pas_short %>
* Deploy the chart into the namespace
* Wait for the deployment to succeed

If <%= vars.product_short %> is configured with a private registry, it will

* Transform the chart's image reference  to pull to from that registry (assuming the image/registry key names used match expectations)
* Add a secret containing the registry credentials to the namespace, so the image can be pulled

###<a id='bind'></a> Bind

On bind, <%= vars.product_short %> looks at the `services` and `secrets` created
in the  namespace created on provision.

If the chart includes a [bind template](./prepare-offer.html#env), these
`services` and `secrets` are fed into that template, processed, and the template
results are used as the credentials.

If the chart does not include a bind template, the `services` and `secrets` are
used directly as credentials (serialized as JSON).

<%= vars.product_short %> takes the credentials and then stores them
in the Pivotal Application Service CredHub.
<%# Not to docs folks: to be technically accurate, this needs to be PAS credhub - can't be platform or something generic %>
The bound application is given permission to read the newly created CredHub variable.

###<a id='update'></a> Update

When a developer invokes update via <%= vars.pas_short %>, Helm's
[upgrade lifecycle](https://github.com/helm/helm/blob/master/docs/helm/helm_upgrade.md)
is triggered for the chart.

* The update will **not** consume a newer version of the chart if one has been offered
* Existing values will be used, so the developer does not need to re-send all the configuration parameters

The use case for update is to add or modify configuration parameters sent via the `-c`
flag on service provision or update.

###<a id='ubind'></a> Unbind

On unbind, <%= vars.product_short %> will delete the CredHub variables
[created during bind](#bind).

###<a id='deprovision'></a> Delete

On deprovision, <%= vars.product_short %> will

* Delete each chart of scope `namespace` created during provision
* Take no action on charts of scope `cluster`
* Delete the namespace in the backing cluster generated during provision
